### 1.1: `@atomic-reactor/reactium-sdk-core` Exploration

-   **Goal:** Understand the building blocks of the Reactium SDK.
-   **Actions:**
    -   Analyze the `package.json` to identify dependencies and main entry points.
    -   Explore the directory structure to map out the provided components, hooks, and utilities.
    -   Document the purpose of each major component and function.
    -   **Verification:** Write simple code snippets or components in `learning/src/app` that utilize the SDK's features.
    -   **Key Module Insights:**
        -   **`Hook.ts`**: This module provides a powerful, event-driven hook system, which is the foundation for extending Reactium's functionality.
            -   **`HookSDK` Class:** Manages the registration, unregistration, and execution of hooks.
            -   **Hook Types:** Supports both `async` (executed in sequence via `ActionSequence`) and `sync` hooks.
            -   **Registration:** Hooks are registered with a `name`, a `callback`, an `order` (for priority), a unique `id`, and a `domain` (for grouping).
            -   **Execution:** The `run()` and `runSync()` methods execute `async` and `sync` hooks, respectively.
            -   **`ActionSequence`:** The use of `ActionSequence` for `async` hooks is a key architectural choice, allowing for a chain of promises where each hook can pass data to the next.
        -   **`Registry.ts`**: Provides a generic, in-memory database for managing collections of objects.
            -   **Core Concept:** A powerful tool for creating named collections of data that can be accessed, modified, and observed.
            -   **Key Features:**
                -   **Generics (`<ItemT>`):** Can store any type of object.
                -   **CRUD-like Operations:** Supports `register`, `unregister`, `get`, `ban`, etc.
                -   **Protection:** Items can be `protect`ed from being unregistered.
                -   **Observer Pattern:** The `subscribe` method allows for notifications on registry changes.
                -   **Modes:** Operates in `CLEAN` (default, performant) or `HISTORY` (tracks all changes) mode.
            -   **Use Cases:** Likely used for managing plugins, components, routes, and other collections of application resources.
        -   **`Pulse` Module (`reactium-sdk-core/src/core/Pulse/index.ts` & `enums.ts`)**: A robust task runner for managing delayed, repeated, and asynchronous operations.
            -   **Core Concept:** Provides a sophisticated scheduler for running functions with more control than standard `setTimeout` or `setInterval`, including lifecycle management, retries, and a centralized task registry.
            -   **`PulseTask<Params extends any[]>` Class:** Encapsulates a single task's logic, state, and lifecycle.
                -   **`PulseTaskOptions`**: Configurable options including `ID`, `callback`, `attempts`, `autostart`, `delay`, `repeat`, and `debug`.
                -   **Private State**: Uses `Symbol`s for internal properties (e.g., `_status`, `_attempt`) to ensure state integrity.
                -   **Lifecycle Management**: Methods like `start()`, `stop()`, `now()`, `onSuccess()`, `onError()`, `reset()`, and `retry()` provide fine-grained control over task execution.
                -   **Retry Logic**: Configurable `attempts` for automatic retries on failure.
                -   **Status & Progress**: Tracks task `status` (from `enums.ts`), `count`, and `progress`.
                -   **`PulseTaskError`**: Custom error for task-specific issues.
            -   **`PulseSDK` Class:** Manages a collection of `PulseTask` instances.
                -   **Task Registry**: Internally stores and manages registered `PulseTask`s.
                -   **CRUD-like Operations**: `get()`, `register()`, `unregister()`, `start()`, `stop()`, `startAll()`, `stopAll()` for managing tasks.
            -   **`enums.ts`**: Defines the `STATUS` enum (ERROR, READY, RUNNING, STARTED, STOPPED) for task states and `ENUMS` constants for default task options and error messages.
            -   **Use Cases:** Ideal for polling, debouncing/throttling, animations, background processes, and any scenario requiring controlled, scheduled, or repeatable asynchronous operations.
        -   **`Server` Module (`reactium-sdk-core/src/core/Server/index.ts`, `annotations.ts`, `docs.js`)**: Provides mechanisms for extending the backend Express server and a powerful annotation processing system.
            -   **Core Concept (Express Integration)**: Primarily a registry for Express middleware, allowing plugins to register their own middleware in a decoupled way.
            -   **`Server.Middleware`**: An exported `Registry` instance (created using `registryFactory` with name `'ExpressMiddleware'`) specifically for managing Express middleware.
            -   **Core Concept (Annotation Processing)**: The `annotationsFactory` function from `annotations.ts` creates processors for extracting and transforming metadata/content embedded in strings.
            -   **`annotationsFactory` Function:**
                -   Takes a `namespace` (e.g., `'reactium'`) and `type` (`'async'` or `'sync'`).
                -   Uses a `Registry` to store `Processor` objects, which are functions that apply transformations to annotation content.
                -   Integrates deeply with the `Hook` system: other modules can register custom processors by implementing a synchronous hook named after the annotation namespace (e.g., `@reactium`), making the system highly extensible.
                -   Includes a default processor that handles `[file:...]` tags, allowing content from specified files to be embedded directly into annotations.
            -   **`docs.js`**: This file contains JSDoc-style comments with `apidoc` tags, serving as source documentation for the `annotationsFactory` function.
            -   **Use Cases**:
                -   `Server.Middleware`: Decoupled management and injection of Express middleware.
                -   `annotationsFactory`: Highly flexible system for processing structured metadata within code or text, enabling use cases like dynamic configuration, documentation generation, and content transformation.
    -   **Browser SDK:**
        -   **The "Handle" Pattern (`Handle.ts`, `useHandle.ts`, `useRegisterHandle.ts`)**: A powerful and decoupled component communication system.
            -   **Core Concept (Handle.ts)**: The `Handle` class (exported as the `ReactiumHandle` singleton) acts as a global, in-memory registry for sharing references (APIs, data, state objects) between components. It incorporates a publish-subscribe mechanism to notify subscribers of changes to the registry.
                -   **`handles`**: An internal object where references are stored, organized by `object-path` IDs.
                -   **`subscriptions`**: A collection of callbacks that are invoked when handles are registered or unregistered.
                -   **Methods**: `register()`, `unregister()`, `get()`, `has()`, `list()`, and `subscribe()` provide comprehensive management and observability.
            -   **`useRegisterHandle<HandleType = any>(ID: Path, cb: () => HandleType, deps = [])`:** A "provider" hook that registers a value (returned by the `cb` function) as a global handle under a given `ID`. The `cb` function is executed to create the handle's value, which is stored internally in a `useRef`.
                -   The hook ensures the handle is registered with `ReactiumHandle` when the component mounts (or `deps` change) and automatically unregistered during cleanup (component unmounts or `deps` change).
                -   `deps`: The dependency array ensures the handle is re-created and re-registered if its underlying values change.
                -   **Use Cases**: Exposing component-specific APIs, managing global services, or providing dynamic resources that need to be globally accessible and have their lifecycle tied to a React component.
            -   **`useHandle(ID: Path)`:** A "consumer" hook that retrieves a registered handle (`HandleType`) by its `ID`. It internally subscribes to the global `ReactiumHandle` registry. When any handle in the registry changes (registered or unregistered), `useHandle` re-fetches the specified handle and forces a re-render of the consuming component if the retrieved handle has changed. This ensures the component always reflects the latest state of the registered handle.
        -   **The "Sync State" Pattern (`ReactiumSyncState.ts` & `useSyncState.ts`)**: A powerful and self-contained state management solution for React components.
            -   **Core Concept (ReactiumSyncState.ts)**: The `ReactiumSyncState` class extends `EventTarget` to create a highly flexible, event-driven, and observable state object. It allows for detailed state manipulation, dispatches events on changes, and supports dynamic extension of its functionality.
                -   **Internal State**: Manages current (`STATE`) and initial (`INITIAL_STATE`) state using private `Symbol`s.
                -   **`object-path` Integration**: Uses `op` (an `object-path` instance) for efficient deep getting, setting, and deleting of nested state properties.
                -   **Event System**: Overrides `addEventListener` to manage listeners by unique IDs. Dispatches rich `ComponentEvent`s (e.g., `'before-set'`, `'set'`, `'change'`, `'before-del'`, `'del'`) for fine-grained reactivity.
                -   **`set()` Method**: Handles state mutations, supporting path-based updates or full state replacement. Features a sophisticated `_conditionallyMerge()` logic (extensible via the `'use-sync-state-merge-conditions'` hook) to control how new values are merged with existing state.
                -   **`extend(prop, method)`**: Enables dynamic addition of new methods to the state instance at runtime, allowing for custom actions and derived state logic.
                -   **Other Methods**: Includes `get()`, `del()`, `insert()`, `reset()`, `has()`, and `coalesce()` for comprehensive state management.
            -   **`useSyncState<T extends object>(initialState: T, updateEvent = 'set')` Hook**: Acts as a factory for creating and providing a local, observable `ReactiumSyncState` instance to a React functional component.
                -   **Core Concept**: This hook instantiates `ReactiumSyncState` and automatically subscribes the component to the `updateEvent` (defaults to `'set'`). This ensures the component re-renders whenever its `ReactiumSyncState` instance dispatches the specified event, making the state reactive within the component.
                -   **Internal Mechanism**:
                    -   Uses `useRef` to maintain a single `ReactiumSyncState` instance throughout the component's lifecycle.
                    -   Leverages `useState` (for `updater` function) and `useEventEffect` to efficiently subscribe to the `ReactiumSyncState` instance's `updateEvent` and trigger component re-renders.
                -   **Return Value**: The `ReactiumSyncState<T>` instance, allowing the component to directly interact with its local, observable state using all the methods provided by `ReactiumSyncState` (e.g., `get()`, `set()`, `extend()`, `dispatch()`).
                -   **Use Cases**: Managing complex component-local state with event-driven updates, serving as the foundation for state objects that will be registered as global handles (via `useRegisterSyncHandle`), and providing a more robust state management solution than standard `useState` for intricate component logic.
        -   **The "Zone" Pattern (`Zone.tsx` & `Zones.ts`)**: A powerful system for creating extensible and pluggable UIs.
            -   **Core Concept**: The `<Zone />` component acts as a placeholder in the UI that dynamically renders other React components registered to a specific named "zone." This allows for highly modular and customizable user interfaces.
            -   **`Zone.tsx` Implementation Details**:
                -   **`useZoneComponents(zone: string)` Hook**: Retrieves and reactively tracks the `ComponentRegistration`s for a given zone from the `ZoneRegistry`. It uses `useSyncState` to manage its internal component list and subscribes to `ZoneRegistry` changes to ensure re-renders when zone components are updated.
                -   **`HookComponent`**: A helper component that dynamically renders a React component by looking it up in the global `ComponentSDK` (which is the `RegisteredComponents` instance) using a provided `hookName`.
                -   **`SimpleZone`**: The default rendering mechanism for a zone. It fetches all registered components and renders them directly, using `HookComponent` for string-based component references.
                -   **`PassThroughZone`**: An alternative rendering mechanism (activated via the `passThrough` prop on `<Zone />`). It clones its `children` and passes the unrendered registered components as a prop (`components`) to them, giving the consumer explicit control over rendering.
                -   **`<Zone />` Component**: The main public-facing component that orchestrates rendering, conditionally rendering either `SimpleZone` or `PassThroughZone`. It is itself registered with the `ComponentSDK`.
            -   **Core Concept (`Zones.ts`)**: The `Zones` class (exported as the `ZoneRegistry` singleton) is the backend management system for the Zone Pattern. It maintains a comprehensive store of component registrations and zone controls (filters, mappers, sorters) and provides a subscription mechanism to notify changes.
                -   **Internal State**: Manages `subscribers`, `components` (including `ComponentRegistration`s with `object-path` IDs), and `controls` (filters, mappers, sorters) for each zone.
                -   **`init()`**: Initializes the registry, fetching default controls and components via the `'zone-defaults'` hook.
                -   **Component Management**: `addComponent()`, `updateComponent()`, `removeComponent()`, `getZoneComponents()`, `getZoneComponent()`, `hasZoneComponent()`. These methods manage the lifecycle and retrieval of components, dispatching various `zone-*` hooks.
                -   **Control Management**: `addControl()`, `addFilter()`, `addMapper()`, `addSort()`, and corresponding `remove*()` methods. These allow dynamic application of transformations to the list of components in a zone.
                -   **Subscription System**: `subscribe(zone, cb)` allows external parties to be notified when the components within a specific zone change.
                -   **Extensibility**: Extensive integration with the `Hook` system for default setup, component lifecycle events, and dynamically influencing filtering, mapping, and sorting processes.
            -   **Use Cases**: Building highly modular applications, enabling plugin architectures, allowing for dynamic UI layouts and content, and supporting advanced theming and customization where UI elements can be swapped or injected.
        -   **`classnames.ts`**: A utility for generating namespaced CSS class names.
            -   **Core Concept**: Provides a factory function (`cxFactory`) to create CSS class name helpers that automatically apply a consistent namespace to classes, preventing collisions and enforcing naming conventions.
            -   **`cxFactory(namespace: string)` Function**:
                -   Takes a `namespace` (e.g., `'my-component'`) and returns a new function.
                -   The returned function accepts arguments similar to the popular `classnames` library.
                -   It processes these arguments using `classnames` and then prefixes each resulting class name with the provided `namespace` (e.g., `'my-component-active'`).
            -   **Use Cases**: Highly beneficial in React component development and design systems for generating predictable, unique, and maintainable CSS class names, thereby improving style encapsulation and organization.
        -   **`Events.ts`**: Provides custom event handling mechanisms for component-level communication.
            -   **Core Concept**: Extends native browser event patterns (`CustomEvent`, `EventTarget`) to offer a structured and extensible way for components to dispatch and listen for custom events with rich payloads.
            -   **`ComponentEvent<T extends EventPayload | undefined>` Class**:
                -   Extends `CustomEvent` to allow event `data` (payload) to be directly accessible as properties of the event object, in addition to the `detail` property.
                -   Handles potential property name collisions and ensures clean data transfer.
            -   **`ComponentTarget` Class**:
                -   Extends `EventTarget`, providing an observable base class for objects that need to emit and handle `ComponentEvent`s.
                -   Includes an `update` method to dynamically set its properties, making it a reactive event source.
            -   **Use Cases**: Enables decoupled component communication, allows for fine-grained observation of component state changes, and facilitates complex, event-driven UI interactions within the Reactium framework.
        -   **`Fullscreen.ts`**: A utility for managing browser fullscreen mode.
            -   **Core Concept**: Encapsulates the Document Fullscreen API to provide a simplified, consistent interface for toggling and querying fullscreen status for a specific DOM element (defaults to the entire document).
            -   **`FullscreenClass` Class**:
                -   Manages fullscreen state (`initialized`, `element`).
                -   `init()`: Sets up a `fullscreenchange` event listener on the `document` to update the `document.body` class (`fullscreen`), enabling CSS styling for fullscreen state.
                -   Provides `isExpanded()`, `isCollapsed()`, `expand()`, `collapse()`, and `toggle()` methods for programmatic control.
            -   **`Fullscreen` Export**: A singleton instance of `FullscreenClass` is exported for easy access.
            -   **Use Cases**: Implementing fullscreen experiences for web applications, media players, presentations, or specific UI components, ensuring consistent behavior across browsers.
        -   **`Prefs.ts`**: A utility for managing user preferences in `localStorage`.
            -   **Core Concept**: Provides a structured interface for reading, writing, and clearing user-specific data that persists across browser sessions using `localStorage`. It supports nested keys via `object-path`.
            -   **`PrefsClass<PrefsType = object>` Class**:
                -   Manages preferences under a specified `storageKey` (defaults to `'ar-prefs'`).
                -   `create()`: Allows for creating new `PrefsClass` instances with custom storage keys.
                -   Provides `get()`, `set()`, and `clear()` methods for CRUD-like operations on preferences.
                -   Integrates `object-path` to enable hierarchical access to preference values.
                -   Includes checks to ensure functionality is limited to browser environments.
            -   **`Prefs` Export**: A singleton instance of `PrefsClass` (using the default key) is exported for application-wide use.
            -   **Use Cases**: Storing user settings (e.g., theme, layout preferences), caching small amounts of client-side data, and providing a consistent API for persistent client-side storage.
        -   **`RegisteredComponents.ts`**: A centralized, observable registry for React components.
            -   **Core Concept**: Extends `ReactiumSyncState` to provide a dynamic and reactive store for managing available React components by ID. This enables dynamic component loading and a plugin-based UI architecture.
            -   **`RegisteredComponents` Class**:
                -   Inherits state management and observation capabilities from `ReactiumSyncState`.
                -   `ComponentRegistry` Interface: Defines the structure for the registry, supporting nested component organizations.
                -   Provides `register(id, component)` and `unregister(id)` methods for managing components.
                -   Offers `listById`, `list`, and `listEntries` getters for easy access to the registered components.
            -   **`Component` Export**: A singleton instance of `RegisteredComponents` is exported, serving as the central component registry for the application.
            -   **Use Cases**: Crucial for enabling dynamic UIs, implementing plugin architectures where components can be added/removed at runtime, and serving as a backend for the "Zone Pattern" to render components in designated areas.
        -   **`splitter.ts`**: A utility for advanced string templating and replacement.
            -   **Core Concept**: Provides a flexible mechanism to split strings based on placeholders (e.g., `"%key%"`) and replace them with dynamic values, maintaining a structured representation of the parts.
            -   **`splitter` Function**:
                -   A recursive function that processes strings or arrays of `Part`s.
                -   Replaces occurrences of `"%key%"` patterns with structured `Part` objects, indicating the type of content (literal string or replacement).
                -   Supports single and batch replacements.
            -   **`Part` Type**: Defines an object with `key`, `value`, and `type` (`'part'` or `'replacement'`) to represent segments of the processed string.
            -   **`SplitParts` Class**:
                -   Manages an `original` string and its `parts` (array of `Part` or `string`).
                -   `reset()`: Resets the `parts` back to the original string.
                -   `replace()`: Executes the `splitter` function to perform replacements.
                -   `value()`: Returns the processed parts as an array of `Part` objects.
                -   `toString()`: Reconstructs the string with all replacements applied.
            -   **Use Cases**: Useful for client-side templating, generating dynamic messages, processing content with embedded variables, and any scenario requiring structured string manipulation.
        -   **`useAsyncEffect.ts`**: A custom React hook for managing asynchronous side effects with proper cleanup.
            -   **Core Concept**: Extends React's `useEffect` to safely handle `async`/`await` operations within functional components, providing a mechanism to prevent memory leaks and state updates on unmounted components.
            -   **`useAsyncEffect(cb: AsyncEffectCallback, deps?: DependencyList)` Hook**:
                -   The `cb` (callback function) is `async` and receives an `isMounted` function. This `isMounted` function allows the effect to check if the component is still mounted before performing state-dependent actions.
                -   The `cb` can return an `AsyncDestroy` promise, which, if resolved to a function, acts as the cleanup logic.
                -   Dependencies (`deps`) work identically to `useEffect`, triggering re-execution when values change.
            -   **`AsyncUpdate` Class**: An internal helper that tracks the mounted state of the component, powering the `isMounted` check.
            -   **Use Cases**: Essential for data fetching (e.g., API calls), setting up and tearing down asynchronous subscriptions (e.g., WebSockets), or managing any long-running asynchronous operation in a React component, ensuring safe state management throughout the component's lifecycle.
        -   **`useDerivedState.ts`**: A custom React hook for managing component state derived from props.
            -   **Core Concept**: Addresses the pattern where a component's internal state is initialized from props but then becomes internally mutable, while still allowing the component to react to specific, subscribed changes in those props.
            -   **`useDerivedState<StateType, PropsType>(props, subscriptions, updateAll)` Hook**:
                -   `props`: The component's current properties used to initialize and potentially update the internal state.
                -   `subscriptions`: An array of `object-path` strings. Only changes to these specific paths within `props` will trigger a re-evaluation of the derived state.
                -   `updateAll`: A boolean. If `true`, when a subscribed prop changes, the _entire_ `props` object is re-imprinted onto the internal state. If `false`, only the changed subscribed path is updated.
                -   **Return Value**: Returns `[state, setState, forceRefresh]`:
                    -   `state`: The current internal state, potentially modified by props or internal calls to `setState`.
                    -   `setState(newExternalState, silent)`: Function to update the internal state, merging `newExternalState`. `silent` prevents a re-render.
                    -   `forceRefresh()`: Triggers a re-render without modifying the state.
            -   **Integration**: Leverages `object-path` for efficient deep property access and `shallow-equals` for optimized change detection of subscribed props.
            -   **Use Cases**: Ideal for creating flexible components that are initially controlled by props but can manage their own internal state, particularly useful in forms, complex UI elements, or scenarios requiring a blend of controlled and uncontrolled behavior.
        -   **`useEventEffect.ts`**: A custom React hook for declarative event listener management.
            -   **Core Concept**: Provides a clean and safe way to add and remove multiple event listeners to an `EventTarget` (like DOM elements, `window`, `document`, or custom event dispatchers) within a React functional component, ensuring proper cleanup.
            -   **`useEventEffect<Target extends EventTarget>(target, handlers, deps)` Hook**:
                -   `target`: The `EventTarget` to which listeners will be attached.
                -   `handlers`: An `EventHandlers` object mapping event types (e.g., `'click'`) to their corresponding callback functions.
                -   `deps`: Dependency array, similar to `useEffect`. The listeners are re-attached if these change.
                -   **`isTarget()` Helper**: Safely checks if an object is a valid `EventTarget` before attempting to add/remove listeners.
            -   **Use Cases**: Managing global events (e.g., `window` resize, keyboard shortcuts), handling custom component events (especially with `ComponentTarget`), and generally streamlining event listener setup and teardown in React functional components.
        -   **`useFocusEffect.ts`**: A custom React hook for programmatic focus management.
            -   **Core Concept**: Simplifies setting focus on a specific element within a designated container (or the document) when a component renders or its dependencies change, enhancing accessibility and user experience.
            -   **`useFocusEffect(container, deps, selectors)` Hook**:
                -   `container`: A React `RefObject<Element>` or direct `Element` reference, defining the scope for focus search.
                -   `deps`: Dependency array, re-triggers the effect if values change.
                -   `selectors`: A CSS selector (defaults to `'*[data-focus]'`) to identify the target element within the container to receive focus.
                -   **Return Value**: `[focusedElement, setFocusedElement]`: A tuple providing the currently focused element (if found) and a function to programmatically set it.
            -   **Use Cases**: Crucial for accessibility (e.g., directing focus to modal content or error messages), guiding user input in forms, and ensuring new UI elements receive appropriate initial focus upon rendering.
        -   **`useFulfilledObject.ts`**: A custom React hook to track the readiness of an object's properties.
            -   **Core Concept**: Monitors an object to determine when all specified nested keys (using `object-path`) have defined values (i.e., are no longer `undefined`), making it suitable for managing asynchronous data readiness.
            -   **`useFulfilledObject(obj, keys, delay)` Hook**:
                -   `obj`: The object whose properties are being monitored.
                -   `keys`: An array of `object-path` strings to check for defined values.
                -   `delay`: The interval (in milliseconds) between checks (defaults to 1ms).
                -   **Return Value**: Returns `[ready, obj, count]`:
                    -   `ready` (boolean): `true` when all specified `keys` in `obj` are defined.
                    -   `obj`: The monitored object itself.
                    -   `count`: The number of checks performed until `ready` becomes `true`.
            -   **Internal Mechanism**: Leverages `useAsyncEffect` and `setInterval` to periodically validate the `obj`'s properties against the `keys` array using `object-path`.
            -   **Use Cases**: Ideal for conditional rendering that depends on multiple asynchronous data points, waiting for complex data structures to be fully populated, or managing the readiness state of resources that are loaded piecemeal.
        -   **`useHookComponent.ts`**: A custom React hook to retrieve components from the registry.
            -   **Core Concept**: Provides a straightforward way to access and render React components that have been registered with the global `Component` registry (an instance of `RegisteredComponents`).
            -   **`useHookComponent(hook, defaultComponent)` Hook**:
                -   `hook`: A string identifier used to look up the desired component in the `Component` registry.
                -   `defaultComponent`: An optional React `ComponentType` to be returned if no component is found for the given `hook`. Defaults to `forwardRefNoop` (which renders `null`).
                -   **Return Value**: The React component associated with the `hook`, or the `defaultComponent` if not found.
            -   **Integration**: Directly uses `Component.get()` to query the component registry. This hook is a key enabler for Reactium's dynamic UI composition and plugin architecture, often used in conjunction with the "Zone Pattern."
            -   **Use Cases**: Dynamically rendering UI elements based on configuration or runtime conditions, allowing for pluggable UI components, and facilitating the extension of Reactium's interface by third-party plugins.
        -   **`useIsContainer.ts`**: A utility function for determining DOM ancestral relationships.
            -   **Core Concept**: Provides an efficient way to check if a given `element` (DOM Node) is a descendant (or the same node) of a specified `match` container (DOM Node) by traversing up the DOM tree.
            -   **`useIsContainer(element: Node, match: Node)` Function**:
                -   `element`: The starting DOM Node (e.g., event target).
                -   `match`: The target ancestor DOM Node (e.g., a component's root element).
                -   **Traversal**: Iteratively moves up from `element` to its `parentNode`s, checking for equality with `match`.
                -   **Return Value**: `true` if `element` is within `match` (or is `match`), `false` otherwise.
            -   **Use Cases**: Commonly used in React for implementing "click outside" functionality, event delegation, determining if an element is within a scrollable area, or general DOM relationship checks in a performance-sensitive manner. Although named `useIsContainer`, it's implemented as a pure function and would typically be called within React hooks like `useCallback` or `useEffect`.
        -   **`useRefs.ts`**: A custom React hook for managing multiple React refs within a single object.
            -   **Core Concept**: Consolidates the management of numerous `useRef` instances into a single, `object-path`-addressable object, simplifying access and organization of references to DOM elements or component instances.
            -   **`useRefs<TRefs extends object>(initialRefs)` Hook**:
                -   Manages an internal object (accessible via `ref.current`) that stores all individual refs.
                -   Provides `get()`, `set()`, `del()`, and `clear()` methods for CRUD-like operations on these refs using `object-path` keys.
                -   **`proxy(key: Path)` Method**: A powerful feature that returns a `Proxy` object, allowing a specific ref within the `useRefs` object to be directly assigned to a `ref` prop in JSX (e.g., `<div ref={refs.proxy('myElement')}>`). This proxy intercepts `current` property assignments to update the internal ref store.
            -   **Use Cases**: Streamlining ref management in components with many child elements, dynamic lists, complex forms, or when building reusable component libraries that need to expose multiple internal references.
        -   **`useRegisterSyncHandle.ts`**: A custom React hook for registering a synchronized state object as a global handle.
            -   **Core Concept**: Combines the `Handle` pattern with `ReactiumSyncState` (via `useSyncState`) to create a global, observable state object that can be owned and managed by a specific component, and then consumed by other components.
            -   **`useRegisterSyncHandle<T extends object>(ID, initialState, updateEvent)` Hook**:
                -   `ID`: The unique identifier (`object-path` compatible) for the handle in the global `Handle` registry.
                -   `initialState`: The initial value for the synchronized state object.
                -   `updateEvent`: The event name used by `ReactiumSyncState` to signal updates (defaults to `'set'`).
                -   **Integration**: Internally uses `useSyncState` to create the observable state and `Handle.register()` to expose it globally.
                -   **Lifecycle**: Automatically registers the handle on mount and unregisters on unmount, ensuring proper resource management.
                -   **Return Value**: The `ReactiumSyncState` instance, allowing the owning component to directly manipulate the synchronized state.
            -   **Use Cases**: Establishing global, component-managed state for application-wide settings, facilitating complex inter-component communication, and providing a standardized way for plugins to expose reactive data. Consumed by `useHandle` (non-reactive) or `useSyncHandle` (reactive) in other components.
        -   **`useScrollToggle.ts`**: A custom React hook for globally controlling page scrolling.
            -   **Core Concept**: Provides a centralized mechanism to enable, disable, and toggle scrolling for the `document.body`, making it invaluable for contexts like modals or full-screen overlays where background scrolling should be prevented.
            -   **Global `BodyScroll` Handle**:
                -   Creates and registers a `ReactiumSyncState` instance under the ID `'BodyScroll'`, allowing other components to observe and control the scroll state.
                -   Extends this handle with `enable()`, `disable()`, and `toggle()` methods for easy scroll management.
            -   **Functionality**:
                -   `disable()`: Locks the page's scroll by applying specific CSS styles to `document.body` and stores the current scroll position.
                -   `enable()`: Restores `document.body`'s default scrolling behavior and scrolls back to the previously stored position.
            -   **Integration**: Leverages `useEffect` to react to changes in the `BodyScroll` handle's state and applies the appropriate scroll logic. It also uses `useSyncHandle` to ensure components consuming this hook re-render when the scroll state changes.
            -   **Use Cases**: Primarily for enhancing user experience in applications that feature modals, lightboxes, or any UI element that temporarily takes over the screen and requires disabling background interaction.
        -   **`useSelectHandle.ts`**: A custom React hook for reactive, granular state selection from a global handle.
            -   **Core Concept**: Allows a component to subscribe to and re-render only when a _specific slice_ of state changes within a `ReactiumSyncState` instance registered as a global handle. This optimizes performance by preventing unnecessary re-renders.
            -   **`useSelectHandle<T extends ReactiumSyncState<object>>(ID, selectorOrCb, defaultValue)` Hook**:
                -   `ID`: The identifier of the `ReactiumSyncState` instance in the global `Handle` registry.
                -   `selectorOrCb`: Can be an `object-path` string (e.g., `'user.name'`) or a callback function `(state: T) => any` that returns the desired slice of state.
                -   `defaultValue`: Optional, used if `selectorOrCb` is a path and the value is not found.
                -   **Return Value**: `{ handle: T, selected: any }` â€“ the full `ReactiumSyncState` instance and the reactive, selected state value.
            -   **Internal Mechanism**: Uses `useHandle()` to retrieve the `ReactiumSyncState` object, `useEventEffect()` to listen for state changes (specifically the `'set'` event), and `useState()` to trigger re-renders only when the _selected_ value actually changes.
            -   **Use Cases**: Highly beneficial for performance-critical components needing access to global state, enabling a Redux-like `useSelector` pattern for Reactium's `Handle` system, and reducing unnecessary component updates.
        -   **`useStatus.ts`**: A custom React hook for managing and reacting to discrete status states.
            -   **Core Concept**: Provides a controlled way to track a component's status (e.g., `'pending'`, `'success'`, `'error'`) with options to trigger re-renders or query the status without re-rendering.
            -   **`useStatus<S extends string>(initialStatus)` Hook**:
                -   `initialStatus`: The starting status string (defaults to `'pending'`).
                -   **Return Value**: `[status, setStatus, isStatus, getStatus]`:
                    -   `status`: The current status (snapshot at render).
                    -   `setStatus(newStatus, forceRender?)`: Updates the status; `forceRender: true` triggers a re-render.
                    -   `isStatus(statuses)`: Checks if the current status matches a given status or any in a list.
                    -   `getStatus()`: Returns the absolute latest status without triggering a re-render.
            -   **Internal Mechanism**: Uses `useRef` for mutable status storage and `useState` (`rerender`) to selectively force component updates.
            -   **Use Cases**: Managing loading states for data fetching, controlling UI workflow steps, conditional rendering based on component lifecycle or operation outcomes, and generally simplifying status management in React components.
        -   **`useSyncHandle.ts`**: A custom React hook for reactively consuming global handles.
            -   **Core Concept**: Enables a React component to subscribe to a `ReactiumSyncState` object (exposed via the `Handle` system) and automatically re-render when the synchronized state changes. This provides a reactive way to consume global state.
            -   **`useSyncHandle<T extends object>(ID, updateEvent)` Hook**:
                -   `ID`: The unique identifier (`object-path` compatible) of the `ReactiumSyncState` instance registered as a handle.
                -   `updateEvent`: The event name (defaults to `'set'`) that the `ReactiumSyncState` instance emits when its state changes, triggering a re-render in the consuming component.
                -   **Return Value**: The `ReactiumSyncState` instance (`handle`) itself, allowing direct interaction with the shared state.
            -   **Internal Mechanism**: Combines `useHandle()` to retrieve the `ReactiumSyncState` instance with `useEventEffect()` to listen for state change events. A `useState()` hook is used to force component re-renders upon receiving the `updateEvent`.
            -   **Use Cases**: Ideal for components that need to display or react to global application state, ensuring their UI remains synchronized with shared data, and completing the reactive communication pattern established by `useRegisterSyncHandle`.
        -   **`window.ts`**: Provides utilities for environment detection and responsive design.
            -   **Core Concept**: Offers safe ways to interact with global browser objects (`window`, `document`) and provides helpers for determining the current environment (browser, Electron) and responsive breakpoints.
            -   **Environment Detection Utilities**:
                -   `conditionalWindow()`, `conditionalDocument()`: Safely return `window` or `document` if available.
                -   `isWindow()`, `isBrowserWindow()`: Check for a browser environment.
                -   `isElectronWindow()`: Detects if running within Electron.
            -   **Responsive Design Utilities**:
                -   `BREAKPOINTS_DEFAULT`: Defines standard screen width breakpoints.
                -   `breakpoints()`: Retrieves active breakpoints, allowing for custom configurations.
                -   `breakpoint(width?)`: Determines the current breakpoint ('xs', 'sm', 'md', etc.) based on window width, aiding responsive UI development.
            -   **Use Cases**: Building universal (isomorphic) JavaScript applications that need to adapt to different execution environments, implementing responsive UI layouts, and executing environment-specific code logic.
    -   **`MemoryCache.ts`**: A robust, observable in-memory cache system.
        -   **Core Concept**: Extends the basic `memory-cache` library with advanced features like path-based key management, subscription to cache changes, and integration with `object-path` for nested data handling.
        -   **Key Features**:
            -   **Path-based Keys**: Uses `object-path` (`Path` type) to allow for hierarchical keys (e.g., `'user.profile.name'`), enabling more organized data storage and retrieval. Includes `sanitizeKey`, `denormalizeKey`, `normalizeKey`, and `getKeyRoot` utilities for managing these keys.
            -   **Subscription Mechanism**: Allows components or other parts of the application to `subscribe` to changes for specific keys or paths. Subscribers are notified (`CacheEventHandler`) when an item is `set` (put), `del`eted, `expire`d, or the cache is `clear`ed or `merge`d.
            -   **CRUD Operations**: Provides `get`, `put` (aliased as `set`), `del`, `clear`, and `merge` methods.
            -   **Expiration**: Supports item expiration with an optional `time` and `timeoutCallback` when using `put`.
            -   **Instance**: Exports a singleton instance `Cache` for easy access throughout the SDK or application.
            -   **Dependencies**: Leverages `object-path` for nested object manipulation, `underscore` for utility functions (`uniq`), `uuid` for generating subscriber IDs, and `dayjs` for handling expiration times during merge operations.
        -   **Use Cases**: Ideal for caching frequently accessed data, configuration settings, or any other dynamic data that benefits from being quickly available and whose changes need to be observed by different parts of the application without direct coupling. This could be used for client-side state management, server-side request caching, or even as a lightweight event bus for data changes.
    -   **`enums.ts`**: Centralizes enumeration and constant values.
        -   **Core Concept**: Provides a single location for important enums and constant values used across the SDK.
        -   **Key Features**:
            -   **`Priority` Enum**: Defines standard priority levels (`core`, `highest`, `high`, `neutral`, `low`, `lowest`) used, for example, in the `Hook` system to determine execution order.
            -   **`Enums` Singleton**: An exported object that bundles various enums and constant configurations (e.g., `cache.settings`).
        -   **Use Cases**: Ensures consistency and easy management of critical numerical and categorical values, particularly for system configuration and ordering.
    -   **`NumberUtils.ts`**: Provides utility functions for number manipulation.
        -   **Core Concept**: Contains helper functions for common number-related tasks.
        -   **Key Features**:
            -   **`abbreviatedNumber(value: number)`**: Converts large numbers into a human-readable abbreviated string (e.g., 1500 -> '1.5k', 2000000 -> '2m').
        -   **Use Cases**: Primarily for UI presentation of numerical data to improve readability.
